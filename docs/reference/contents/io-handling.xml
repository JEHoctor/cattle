<refentry id="io-handling">

	<refmeta>
		<refentrytitle>I/O Handling</refentrytitle>
		<manvolnum>3</manvolnum>
		<refmiscinfo>CATTLE Library</refmiscinfo>
	</refmeta>

	<refnamediv>
		<refname>I/O Handling</refname>
		<refpurpose>
			Explanation of the way Cattle performs input and output
		</refpurpose>
	</refnamediv>

	<refsect2>

		<title>I/O Basics</title>

		<para>
			Cattle uses an I/O mechanism which allows for a huge degree
			of flexibility while remaining relatively simple.
		</para>

		<para>
			The I/O mechanism is based on the GObject signal system:
			every time a
			<link linkend="CattleInterpreter">CattleInterpreter</link>
			executes a Brainfuck instruction which requires some sort of
			I/O, it emits a signal, and expects the installed signal
			handler to perform the I/O operation.
		</para>

		<para>
			The signals for input, output and debug output are
			&quot;<link linkend="CattleInterpreter-input-request">input-request</link>&quot;,
			&quot;<link linkend="CattleInterpreter-output-request">output-request</link>&quot;
			and
			&quot;<link linkend="CattleInterpreter-debug-request">debug-request</link>&quot;
			respectively; default signal handlers are built into Cattle,
			removing the need to write custom I/O routines in most cases.
		</para>

		<para>
			Only the first connected handler will be executed on signal
			emission; connecting a custom handler will prevent the default
			signal handler from running.
		</para>

		<para>
			All signal handlers are passed the running
			<link linkend="CattleInterpreter">CattleInterpreter</link>
			as first argument and a <link linkend="GError">GError</link>
			as last argument; handlers are required to fill in the latter
			with a detailed error message if the operation couldn't be
			completed.
		</para>

	</refsect2>

	<refsect2>

		<title>Output handler</title>

		<para>
			The output handler is pretty straightforward: the handler
			is passed a single <link linkend="gchar">gchar</link> and
			has to display it to the user in some way.
		</para>

		<para>
			As an example, here is an handler which shows the output of
			a Brainfuck program on a
			<link linkend="GtkTextView">GtkTextView</link>:
		</para>

		<informalexample><programlisting>
			gboolean
			output_handler (CattleInterpreter  *interpreter,
			                gchar               output,
			                GError            **error,
			                gpointer            data)
			{
				GtkTextView *view;
				GtkTextBuffer *buffer;
				GtkTextIter iter;
				gchar text[2];

				view = GTK_TEXT_VIEW (data);

				/* Get the buffer used by the GtkTextView */
				buffer = gtk_text_view_get_buffer (view);
				g_object_ref (buffer);

				/* Get a reference to the end of the buffer */
				gtk_text_buffer_get_end_iter (buffer, &amp;iter);

				/* Create a string */
				text[0] = output;
				text[1] = (gchar) 0;

				/* Insert the char at the end of the buffer */
				gtk_text_buffer_insert (buffer, &amp;iter, text, 1);

				g_object_unref (buffer);

				return TRUE;
			}
		</programlisting></informalexample>

		<para>
			The code assumes a <link linkend="GtkTextView">GtkTextView</link>
			has been passed as the <code>data</code> argument at signal
			connection time, like in the following code:
		</para>

		<informalexample><programlisting>
				CattleInterpreter *interpreter;
				GtkWidget *view;

				interpreter = cattle_interpreter_new ();
				view = gtk_text_view_new ();

				g_signal_connect (interpreter,
				                  "output-request",
				                  G_CALLBACK (output_handler),
				                  (gpointer) view);
		</programlisting></informalexample>

		<para>
			Depending on the case, it may make sense for the application
			to buffer an entire line of output, or even the whole output,
			before sending it to its intended destination.
		</para>

	</refsect2>

	<refsect2>

		<title>Input handler</title>

		<para>
			Input is a little more complicated than output, but it's
			still quite easy to write custom handlers, as long as one
			follows the conventions explained here.
		</para>

		<para>
			Here is an input handler which uses readline to fetch input
			from the user:
		</para>

		<informalexample><programlisting>
			gboolean
			input_handler (CattleInterpreter  *interpreter,
			               gchar             **input,
			               GError            **error,
			               gpointer            data)
			{
				char *temp;

				/* If *input is NULL, a previously read line of input has
				 * been completely processed by the interpreter and is's
				 * not needed anymore, so free it */
				if (*input != NULL) {
					g_free (*input);
				}

				/* Read an input line using readline (no prompt) */
				temp = readline (NULL);

				if (temp != NULL) {

					/* A line of input has been read: since readline
					 * strips the trailing newline but the interpreter
					 * needs it, a new string with a trailing newline is
					 * created and returned to the interpreter */
					*input = g_strdup_printf ("%s\n", temp);
					free (temp);
				}
				else {

					/* readline returns NULL when the end of input has
					 * been reached; to let the interpreter know no more
					 * input is available, set *input to NULL */
					*input = NULL;
				}

				return TRUE;
			}
		</programlisting></informalexample>

		<para>
			Input works on a per-line basis: the signal handler must
			retrieve a full, null-terminated line of input, including the
			trailing newline character, and feed it to the interpreter.
		</para>

		<para>
			If it is not possible to retrieve the whole line in a single
			step, a part of it can be passed to the interpreter. The
			string still needs to be null-terminated.
		</para>

		<para>
			Since the interpreter doesn't make a copy of the input string,
			the handler must make sure it will be accessible as long as
			the interpreter needs it. This usually means a newly-allocated
			string must be returned.
		</para>

		<para>
			No allocator choice is forced on the user: the handler is
			responsible of releasing the allocated buffer when the
			interpreter is done processing it. This condition is notified
			to the handler by passing a non-null pointer as the second
			argument.
		</para>

		<para>
			When the whole input has been consumed (EOF condition), the
			handler must set to NULL the pointer to let the interpreter
			know no more input is available.
		</para>

	</refsect2>

	<refsect2>

		<title>Debug</title>

		<para>
			The debug handler is called whenever a <code>#</code>
			instruction is executed; the interpreter can be configured
			to ignore this instruction, since it's not (strictly
			speaking) part of the Brainfuck language.
		</para>

		<para>
			The handler must display useful debugging information to
			the developer; usually, this means dumping the contents of
			the memory tape.
		</para>

		<para>
			The following handler appends the contents of the tape to
			an log file:
		</para>

		<informalexample><programlisting>
			gboolean
			debug_handler (CattleInterpreter  *interpreter,
			               GError            **error,
			               gpointer            data)
			{
				CattleTape *tape;
				gchar value;
				FILE* fp;

				tape = cattle_interpreter_get_tape (interpreter);

				/* Save the current tape position */
				cattle_tape_push_bookmark (tape);

				fp = fopen (LOG_FILE, "a");

				if (fp == NULL) {

					/* Set the error, release resources and return */
					g_set_error_literal (error,
					                     CATTLE_INTERPRETER_ERROR,
					                     CATTLE_INTERPRETER_ERROR_IO,
					                     strerror (errno));
					cattle_tape_pop_bookmark (tape);
					g_object_unref (tape);

					return FALSE;
				}

				/* Rewind to the beginning of the tape */
				while (!cattle_tape_is_at_beginning (tape)) {

					cattle_tape_move_left (tape);
				}

				fprintf (fp, "[ ");

				/* Repeat until the end of the tape is reached */
				while (!cattle_tape_is_at_end (tape)) {

					/* Get the current value */
					value = cattle_tape_get_current_value (tape);

					/* Show printable values directly and non-printable
					 * values as their decimal ASCII value */
					if (value &gt;= 33 &amp;&amp; value &lt;= 126) {
						fprintf (fp, "%c ", value);
					}
					else {
						fprintf (fp, "\\%d ", (gint) value);
					}

					cattle_tape_move_right (tape);
				}

				fprintf (fp, "]\n");
				fclose (fp);

				/* Restore the original tape position */
				cattle_tape_pop_bookmark (tape);

				g_object_unref (tape);

				return TRUE;
			}
		</programlisting></informalexample>

		<para>
			After the handler has run, the tape must be in the same exact
			state it was before the signal emission, including the
			position. The best way to ensure it is to use
			<link linkend="cattle-tape-push-bookmark">cattle_tape_push_bookmark()</link>
			and
			<link linkend="cattle-tape-pop-bookmark">cattle_tape_pop_bookmark()</link>.
		</para>

	</refsect2>

</refentry>
